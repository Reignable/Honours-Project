\subsection{Introduction}
	This chapter will give an outline of the methodologies used to complete the work identified in the previous chapters as well as the reasons for using these methods and alternatives which could have been used. The effectiveness of these methods can determine the success of the project so the chosen methods were required to reliable and manageable. A technical approach was identified for the most appropriate way to produce a solution to the problem identified and a project management approach was decided on so that the project could remain on track and meet the required deadline.
\subsection{Literature Review}
\subsection{Platform}
	As a proof of concept, the final product of this software project could take a variety of forms. Inline with current products on the market an application for Android could be produced which would demonstrate the capabilities of image analysis on a mobile device. Alternatively, the image analysis algorithm can be produced in the Python programming language as a script creating a simpler prototype but clarifying the solution to the problem.
	\subsubsection{OpenCV}
		OpenCV is an open-source computer vision library created for a variety of platforms. Originally released by Intel in 1999\todo{cite} the library was intended as a research project to aid in CPU intensive visual applications. In 2012 the library was taken over by OpenCV.org\todo{cite}, a non-profit organisation who maintain support and the documentation. Though the library is written in C and C++, modules are available for Python, Fortran, and the Android platform.
		\\\\
		This project will use OpenCV as it is widely accepted as the best, free computer vision library available\todo{cite?} and provides functions for the various processes this project will require. Additionally it is well supported and documented which will aid in the development process.
	\subsubsection{Experimentation}
		To further understand what may be required to produce both the Android and Python based approaches and aid in deciding which method to use some basic experiments were carried out to compare the two. For the Android experiments some example applications which are bundled with the OpenCV library were hand copied and run on a mobile device. This allowed their output and functionality to be seen as well as experience in using OpenCV on Android. For the Python based approach, tutorials from the site \url{www.pyimagesearch.com} created by Adrian Rosebrock and \url{www.pythonprogramming.net} creators name unknown were followed and run on a desktop computer.
		\\\\
		Appendix \ref{app:android_experiments} shows the experiments which were carried out on the android platform. It should be noted that, while all applications do not show compilation errors and were adjusted to work with the updated version of Android which the device was using, only two of the four experiments work successfully. Although a stack trace of the errors produced they are not descriptive about the cause of the error. This is due to how OpenCV works on the Android system.
		\\\\
		Alongside the Android \gls{sdk}, Google provide a \gls{ndk} to allow modules which were not written in Java to be run on Android devices. The \gls{ndk} understands various programming languages and applied a Java wrapper around them which is capable of extracting their functionality; this must be applied when using OpenCV on Android as it is written in C++. An artefact of using the \gls{ndk} is that it cannot convert the stack trace produced by errors in the C++ module and after research into this issue it was found that this is difficult to rectify.
		\\\\
		The two working Android experiments do not operate as expected either. Shown in appendix \ref{app:android_experiments} the issues with each can be seen. Although steps were taken to rectify the orientation in the Hello CV experiment and the full-screen issue in both, any fix which was applied was not accepted by the system. Research and debugging of these faults did not produce any conclusions.
		\\\\
		Appendix \ref{app:python_experiments} shows the experiments which were carried out using Python. These were much more successful than the Android experiments as they are all functional and work as expected.
		\\\\
		Included in appendix \ref{app:android_experiments} and \ref{app:python_experiments} as a comparison between the two methods are the number of files and lines of code required to create the program as well as the relevant source code for each program. There is a clear difference between the two methods. The Android method taking an average of 295 lines of code over 3 files to produce arguably less complex and less functional applications than is produced by Python's 21 lines of code over 1 file.
		\\\\
		Due to the difficulties when using OpenCV on Android and as the operating system is already a proven platform for mobile applications the decision has been made to produce a poof of concept for the image analysis in Python. This will allow the project to maintain focus on the analysis and algorithmic side of the problem as opposed to the portability. The decision also allows for more time to be spent making the program functionally stable which will serve as a better demonstration of the solution.
\subsection{Project Management}
	\subsubsection{Agile Development}
		Introduced in 2001 with the writing of the Agile manifesto \citep{beck2001manifesto}, agile development methodologies focus on high quality software products over the rigorous design based structure of traditional waterfall methods. By utilising various techniques such as stand-up meetings, a strong customer focus, and sprint cycles, agile has become widely adopted in industry and has been proven to produce successful projects \citep{state_of_agile_2015}.
		\\\\
		There are multiple agile methodologies (XP, Scrum, DSDM) all with their own principles and techniques however it is commonplace for a company to create their own development method which picks items from each to tailor to their needs\todo{cite}. As this is a solo project with no customer then one set methodology will not be used, instead a variety of methods which will aid the management of the project and increase the efficiency of the development process have been selected. These will be outlined in the following sections.
		\paragraph{Requirements Analysis}
			Used in some form by the majority of agile methodologies \todo{cite}, requirements analysis or requirements engineering is a variety of processes used to create the conditions that a project must meet. These requirements take into account stakeholders, users, and the development team or teams. Each requirement should be documented, actionable, measurable, testable, and traceable to aid in its understanding and completion\todo{cite}.
			\\\\
			The techniques used to produce requirements include stakeholder identification and interviews which are used to identify what the stakeholders of the project require upon completion. These interviews may be followed by Joint Requirements Development Sessions which bring stakeholders together to further discuss the requirements of the project. A more traditional approach is to produce a contract-style requirements list though these are commonly extensive and incomplete due to their production without collaboration. The most used requirements analysis technique in agile development are use cases and user stories. These are either written or diagrammatic descriptions of how the system will interact with users or other systems and provide an indication of what will be required from the product.
			\\\\
			Due to the prototype nature of the application being produced and as the project has no defined stakeholders the only requirements analysis technique which will be used is production of use cases. These will aid in identifying how the application will be operated by users and what the project will need to produce. These requirements will then be prioritised using the MoSCoW format and inserted into a tracking system for the development process; these are described in the following sections.
		\paragraph{MoSCoW}
			First used in the DSDM agile framework\todo{cite}, MoSCoW analysis or prioritisation is the process of taking the requirements of a software product and placing them into one of four categories; must, should, could, and won't have. These deliverables may be prioritised for the entire project or for individual sprint cycles depending on the size and manageability of the project.
			\\\\
			MoSCoW was created to provide customers a better understanding of software requirements. Opposed to using high, medium, and low priorities MoSCoW is more descriptive of what the prioritisation means for the software project. From a development point of view the prioritisation process allows developers to focus on the core requirements of the project first, creating a viable software solution early on with extra features being added later if the resources are available.
			\\\\
			This project will use MoSCoW to prioritise the requirements identified using the requirements analysis technique allowing the development process to complete the goals in the correct order. This will ensure that the core aspects of the solution are implemented first creating a successful project early and allowing it to improve as time allows.
		\paragraph{Sprint Cycles}
			Used by Scrum development teams\todo{cite}, a sprint is a timeboxed effort of work scheduled to take between one week and one month. At the start of a sprint goals are chosen from the project requirements which are to be completed by the end of the sprint. When a sprint is complete a retrospective is carried out by the development team to discuss what went well, what didn't, and how this can be rectified for the next sprint.
			\\\\
			This project will use sprints in the same manner as an agile development team as this will allow easier completion of requirements and management of the development process. Using sprints will ensure the time allotted for development is used effectively which will lead to a higher quality product at the end of the project.
			\\\\
			As mentioned previously, MoSCoW prioritised requirements will be selected at the start of each sprint cycle to set objectives the work which will be carried out. Each cycle will aim to complete all of the must have requirements and the majority of should and could haves. At the end of each cycle a retrospective will be carried out which will re-prioritise the uncompleted requirements based on how successful the sprint cycle was. This means requirements may be promoted or demoted respectively.
	\subsubsection{Version Control}
		Large software projects produce multiple files of code and documentation which are vital and must be kept safe. Were the files to be lost then the project would be delayed or drawn to a close as the time and resources may not be available to recreate the lost data. To combat this any data relating to the project must be backed up, preferably on a cloud based system, to avoid loss and allow the project to continue should anything happen to the local copy of the data.
		\\\\
		For this project the Git \gls{vcs} will be used. Git provides use of a cloud hosted repository to store any files relating to a project and allows for work to be carried out locally by cloning the repository on a computer. However \glspl{vcs} also enable the management of the previous versions of files including information such as the individual changes made, when those changes were made, and who made the changes. This is a powerful tool as it means the various sections of the project can be experimented on without the risk of damaging the project; if a change is unsuccessful then the repository can be reverted to a functional point.
		\\\\
		The web service used to host the repository will be github.com. This site was chosen as it provides unlimited free repositories as well as simple repository management tools. The website also provides issue tracking functionality; though they are not issues, each feature will be added as an entry in the issue tracker. The reason for this is that all features will have a unique identification and description which commits to the repository can be placed against. This is useful for project management reasons as then each feature's stage and completeness can be monitored to ensure the project's success.
		\\\\
		Alternative \glspl{vcs} are available, for example Microsoft's Team Foundation Server or Perforce, however these are limited under free licences or locked to certain development environments. The accessibility and ease of use provided by Git makes it the optimum \gls{vcs} to use for this project. 
	\subsubsection{Milestones}
		Milestones are used in project management to mark significant events or points within a project's timeline. This allows a further breakdown of the project as milestones can be used as supplementary deadlines. The use of milestones allows the project manager, management team, or development team to keep track of the project's status and priorities at any given time.
		\\\\
		This project has and will use milestones for the same reason. Current examples include the week nine review session and deadline for the completion of this document. As more milestones are identified through breakdown of the development process they will be documented and acted upon.
	\subsubsection{Gantt Chart}
		A Gantt chart is a method of plotting a project's schedule which was invented by Henry Gantt in the 1910s. By breaking down a project into tasks these can then be added to the chart as a bar. Commonly starting at a project's inception date and ending with it's completion date, tasks are allocated an estimated duration for their completion and placed within the timeline. These tasks can then be allocated dependencies to indicate their prerequisites.
		\\\\
		This project will make full use of the Gantt chart technique by reducing the project into multiple stages for both writing and development. Previously mentioned milestones will also be added for the known fixed points. Each sprint cycle for the development process will be indicated with further notes on the tasks to be carried out. To create the chart Microsoft Project 2016 will be used.
\subsection{Testing}
	To verify the functionality and quality of a software application it must be tested. This can be carried out at a variety of levels from testing a single class method to an entire system and by knowing how an application works in white-box testing or being unaware of the functionality in black-box testing.
	\subsubsection{Unit Testing}
		Unit testing is carried out on individual units of source code to ensure they are functioning correctly. Normally carried out in the scope of an individual class or module these unit tests are typically written by the same software developer who produced the class itself. A single unit test comprises of a set-up process where data and objects are initialised, the test itself including an assertion on a variable determining pass or fail, and a tear-down process where any changes the test has made are cleared up.
		\\\\
		As unit tests are simple in structure and quick to run then they are commonly executed when changes are made to the source code. This verifies that the changes made have not broken other sections of code and can be committed into the master branch successfully. If a test failure does occur then each unit test should be concise and descriptive enough to aid the debugging process by indicating what has failed and where.
		\\\\
		A metric of quality for unit testing is code coverage. To confirm that a class is of good quality and functional, every possible path through the code must be tested. Testers should aim for 100\% coverage of a module meaning every possible piece of functionality has an associated test, a coverage of 85\% for example means 15\% of a module is not under test and could cause undetected problems if any changes are made. Many IDEs or testing suites provide coverage checking functionality to make this process simple.
	\subsubsection{Python Unit Testing}
		
\subsection{Evaluation}