\section{Methodology}\label{sec:methodology}
	\subsection{Introduction}
		This chapter gives an outline of the methodologies used to complete the work identified in the previous chapters as well as the reasons for using these methods and rejecting alternatives that could have been used. The effectiveness of these methods determines the success of the project so those chosen need to be both reliable and manageable. A technical approach was identified for the most appropriate way to produce a solution to the problem identified and a project management approach was decided on so that the project could remain on track and meet the required deadline.
	\subsection{Literature Review}
		The purpose of the literature review presented in section \ref{sec:lit_review} of this dissertation is to outline, investigate, and clarify the subject areas with which this project is involved. This aids both the reader and author in understanding these subject areas and helps to explain how the project presents a viable solution to the problem area.
		\\\\
		There are numerous forms a literature review can take although not all have the same aims. A traditional or narrative review can be carried out to critique a body of literature and potentially locate inconsistencies \citep{adams2007research}. This type of review is normally used when the research question is well defined. Alternatively a systematic literature review can be undertaken although this requires a more rigorous process and takes more time. Systematic reviews aim to locate previous studies that are within the same or similar subject areas and gain insight to expedite answers to the questions presented by the research \citep{kitchenham2009systematic}.
		\\\\
		For this project a combination of both methods has been used. A systematic approach was applied to investigate how image analysis is used and ascertain which particular techniques were relevant to the use of IA in the context of mountain bike suspension. A traditional method has been applied to examine the uses of image analysis in sports science to determine whether previously used techniques would transfer to mountain bike suspension and provide some idea of how effective they could be.
		\subsubsection{Source Selection}
			Regardless of which types of review was chosen, it was necessary to adopt a methodological approach to identify sources relevant to the project. Multiple services are available for viewing academic papers online and for this project the Edinburgh Napier University library and Google Scholar were utilised as between them they provide an expansive library to select from using a variety of advanced search filters.
			\\\\
			As the  application of advanced technologies to mountain bike suspension is in its infancy and commercially driven, much of the research is undertaken by the manufacturers themselves so there were no academic sources to use. As a result, numerous multiple mountain bike websites and blogs have been cited. In a subject area where the research is more established this would be frowned upon as such sources tend to be biased and often unproven. However it was entirely unavoidable.To overcome author bias, multiple sources have been cited wherever possible as a way of providing different viewpoints on the same topic.
			\\\\
			To determine whether a source is suitable requires a methodical and critical approach. Even before reading a paper or article, it is possible to decide whether the subject matter and research is up to date by referring to its publication date. Such an approach was adopted for this project in order to identify the most recent research available. As a second step, online libraries provide metrics about the number of times a paper has been cited elsewhere; the inference being that papers that have been cited most are both more relevant and trustworthy. However, applying this rule of thumb needed care as some papers are cited so frequently purely because they are the most controversial. Finally when reading a paper, the abstract should be read first followed by the conclusions. This takes little time and taken together, the abstract and conclusions provide a good indication of whether the paper contains relevant and reliable research. Only then should the body of the paper be read in its entirety. 
	\subsection{Platform}
		As a proof of concept, the final product of this software project could take a variety of forms. In line with current products on the market, an application for Android could be produced which would demonstrate the capabilities of image analysis on a mobile device. Alternatively, the image analysis algorithm can be produced in the Python programming language as a script creating a simpler prototype but clarifying the solution that is the core of the problem.
	\subsubsection{OpenCV}
		OpenCV is an open-source computer vision library created for a variety of platforms. Originally released by Intel in 1999 \citep{bradski2008opencv} the library was intended as a research project to aid in CPU intensive visual applications. In 2012 the library was taken over by OpenCV.org \citep{opencvsite}, a non-profit organisation who provide support and documentation. Although the library is written in C and C++, modules are available for Python, Fortran, and the Android platform.
		\\\\
		This project will use OpenCV as it is widely accepted as the best, free computer vision library available and provides functions for the various processes this project requires. Additionally it is well supported and documented which will aid in the development process.
	\subsubsection{Experimentation}\label{sec:methodology_platform_experiments}
		To further understand what may be required to produce both the Android and Python based approaches and aid in deciding which method to use some basic experiments were carried out to compare the two. For the Android experiments some example applications which are bundled with the OpenCV library were hand copied and run on a mobile device. This allowed their output and functionality to be seen while simultaneously gaining experience in using OpenCV on Android. For the Python based approach, tutorials from the \url{www.pyimagesearch.com} website created by Adrian Rosebrock \citep{pyimagesearch} and the \url{www.pythonprogramming.net} website \citep{pythonprogramming} were followed and run on a desktop computer.
		\\\\
		Appendix \ref{app:android_experiments} shows the experiments which were carried out on the Android platform. It should be noted that, while all applications do not show compilation errors and were adjusted to work with the updated version of Android which the device was using, only two of the four experiments worked successfully. Although a stack trace of the errors was produced they do not explain the cause of the error. This is due to how OpenCV works on the Android system.
		\\\\
		Alongside the Android \gls{sdk}, Google provide a \gls{ndk} to allow modules which were not originally written in Java to be run on Android devices. The \gls{ndk} understands various programming languages and applied a Java wrapper around them that is capable of extracting their functionality. This must be applied when using OpenCV on Android as it is written in C++. An artefact of using the \gls{ndk} is that it cannot convert the stack trace produced by errors in the C++ module and following research into this issue it was found that this is difficult to rectify.
		\\\\
		The two working Android experiments do not operate as expected either. Appendix \ref{app:android_experiments} shows the issues with each that were encountered in the test. Although steps were taken to rectify the orientation in the Hello CV experiment and the full-screen issue in both, any fix which was applied was not accepted by the system. Research and debugging of these faults did not rectify these issues to produce an acceptable outcome. Appendix \ref{app:python_experiments} shows the experiments that were carried out using Python. These were much more successful than the Android experiments as they are all functioned and worked exactly as anticipated.
		\\\\
		Appendices \ref{app:android_experiments} and \ref{app:python_experiments} show a comparison between the two methods including the number of files and lines of code required to create the program as well as the relevant source code for each program. There is a clear difference between the two methods. The Android method taking an average of 295 lines of code over 3 files to produce arguably less complex and less functional applications than is produced by Python’s 21 lines of code over 1 file.
		\\\\
		Due to the difficulties encountered when using OpenCV on Android, the decision has been made to produce a proof of concept for the image analysis in Python which also benefits from being an operating system that is already a proven platform for mobile applications. This will allow the project to maintain focus on the analysis and algorithmic side of the solution as opposed to its portability. The decision also allows for more time to be spent making the program functionally stable which will serve as a better demonstration of the solution.
	\subsection{Source Code}
		\subsubsection{Pythonic Coding}
			A metric of software quality is the conciseness and descriptiveness of the source code. The aim of the Python programming language is to complete the same tasks as other object oriented languages but in fewer lines and in a more readable manner \citep{kuhlman2009python}. By removing brackets and instead using indentation to define the boundaries of classes, functions, and conditionals as well as using worded operators, Python creates source code which reads like a list of instructions for people rather than computersas shown in Listing \ref{lst:python_example}. The source code for this project will be written in a pythonic way where it makes sense to do so.
\begin{listing}[ht]
\begin{minted}
[frame=lines,
breaklines,
fontsize=\footnotesize,
linenos]
{python}
long_string = 'This is a very long string'
if 'long' in long_string:
    print 'Match found'
\end{minted}
\caption{An example of Python code}
\label{lst:python_example}
\end{listing}
		\subsubsection{Naming}
			As well as the readability which comes with Python, further efforts will be made to ensure all classes, methods, and variables will be named as descriptively as possible. This makes the system and its algorithms easier for an outsider to understand if any parts of the code need to be revisited at a later date. This is demonstrated in Listing \ref{lst:bad_naming_examples}, where although the left-hand code looks cleaner, when read through looks extremely generic and could be part of any system. In contrast the right-hand code is much more descriptive of its function.
\begin{figure}[!h]
	\begin{minipage}{0.5\textwidth}
		\centering
		\begin{minted}
		[frame=lines,
		breaklines,
		fontsize=\footnotesize,
		linenos]
		{java}
public List<int[]> getThem() {
  List<int[]> list1 = new ArrayList<int[]>();
  for (int[] x : theList)
    if (x[0] == 4)
      list1.add(x);
  return list1;
}
		\end{minted}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
		\centering
		\begin{minted}[frame=lines,
		breaklines,
		fontsize=\footnotesize,
		linenos]
		{java}
public List<int[]> getFlaggedCells() {
  List<int[]> flaggedCells = new ArrayList<int[]>();
  for (int[] cell : gameBoard)
    if (cell[STATUS_VALUE] == FLAGGED)
      flaggedCells.add(cell);
  return flaggedCells;
}
		\end{minted}
	\end{minipage}
	\captionof{listing}{Examples of bad naming (left) and proper naming (right) taken from Clean Code \citep{martin2009clean}}
	\label{lst:bad_naming_examples}
\end{figure}
	\subsubsection{Object Orientation}
		Object orientation is the use of classes which contain their specific variables and methods to protect functionality from other parts of a system. An object oriented approach will be taken when creating the system to ensure its functions and data is protected should it ever be used as a module elsewhere. The use of private variables and methods with one or two public methods provides an \gls{api} with which other developers can use the system.
		\\\\
		Python does not provide the private and public keywords as found in the Java or C++ languages. Instead it identifies methods and variables prefixed by one or two underscores as protected. This means these items will be hidden from view in autocompletion systems or documentation but remain accessible should the developer require them. The creators of Python chose this method as they enforce responsibility over restriction.
\subsection{Testing}
	To verify the functionality and quality of a software application it must always be tested. This can be carried out at a variety of levels from testing a single class method to an entire system and by knowing how an application works in white-box testing or being unaware of the functionality in black-box testing.
	\subsubsection{Unit Testing}
		Unit testing is carried out on individual units of source code to ensure they are functioning correctly. Normally carried out in the scope of an individual class or module, these unit tests are typically written by the same software developer who produced the class itself. A single unit test comprises of a set-up process where data and objects are initialised, the test itself including an assertion on a variable determining pass or fail, and a tear-down process where any changes to data or memory the test has made are cleaned up.
		\\\\
		As unit tests are simple in structure and quick to run they are commonly executed when changes are made to the source code. This verifies that the changes made have not broken other sections of code and can be committed into the master branch successfully. If a test failure does occur then each unit test should be concise and descriptive enough to aid the debugging process by indicating what has failed and where.
		\\\\
		A metric of quality for unit testing is code coverage. To confirm that a class is of good quality and functional, every possible path through the code must be tested. Testers should aim for 100\% coverage of a module meaning every possible piece of functionality has an associated test with a coverage of 85\% for example meaning that 15\% of a module is not under test and could cause undetected problems if any changes are made. Many integrated developers environments (IDEs) or testing suites provide coverage checking functionality to make this process simple.
		\paragraph{Python Unit Testing}
			Due to the package based and open-sourced nature of the Python programming languages there are many implementations of unit testing frameworks to choose from. Each has its own advantages and disadvantages and there is much debate over which framework is the best to use. A good unit testing framework should provide the necessary functions to create simple unit tests for each path in the source code and be substantial enough to ensure the class or module is correctly tested.
	\subsubsection{Project Testing Scope}\label{sec:project_testing_scope}
		Due to the small size of the application which will be produced in this project, testing will be limited to unit testing as there is no integration to be carried out. This small size also means that 100\% code coverage will be simple to achieve. From this, stability and functionality of the application can be verified improving the quality of the overall product.
		\\\\
		Once the basic functionality has been added to the application, unit tests will be created covering all source code produced including normal operation and sections which can potentially produce errors. This means any subsequent changes can be tested to see if they have affected functionality. Any new functionality will have tests added to the testing suite to maintain 100\% coverage.
		\\\\
		The Python unit testing framework chosen is unittest2. Although it has been superseded by Python3, Unittest is the default framework used by the PyCharm \gls{ide}. The unittest2 module provides a backport of this functionality for use in Python2 meaning extra testing functions are provided to allow more suitable tests to be created. PyCharm also provides the ability to run tests with code coverage producing a clear indication of which sections of source code are covered and which are not. This will be greatly beneficial to achieving full coverage.
\subsection{Project Management}\label{sec:project_management}
	\subsubsection{Agile Development}
		Introduced in 2001 with the writing of the Agile manifesto \citep{beck2001manifesto}, agile development methodologies focus on the rapid delivery of high quality software rather than rigorous design-based structure of traditional waterfall methods. By utilising various techniques such as stand-up meetings, a strong customer focus, and sprint development cycles, agile has become widely adopted in industry and has been proven to produce successful projects that are both more closely tailored to the customers’ needs and delivered in shorter time scales \citep{state_of_agile_2015}.
		\\\\
		There are numerous agile methodologies (XP, Scrum, DSDM) each with their own principles and techniques. However it is commonplace for a company to create their own agile approach picking and choosing items from different methodologies to suit their particular needs \citep{aydin2004agile}. As this is a solo project with no customer then a single set methodology will not be used. Instead a variety of methods may be used to help manage the project and drive the efficiency of the development process. These potential methods will be outlined in the following sections.
		\paragraph{Requirements Analysis}
			Used in some form by the majority of agile methodologies \citep{cao2008agile}, requirements analysis or requirements engineering is a variety of processes used to create the conditions that a project must meet. These requirements take into account stakeholders, users, and the development team or teams. Each requirement should be documented, actionable, measurable, testable, and traceable to aid in its understanding and completion.
			\\\\
			The techniques used to produce requirements include stakeholder identification and interviews which are used to identify what the stakeholders of the project require once it is completed. These interviews may be followed by Joint Requirements Development Sessions which bring stakeholders together to further discuss the requirements of the project. A more traditional approach is to produce a contract-style requirements list although these are typically extensive and incomplete as considerable collaboration is involved in producing them. The requirements analysis techniques that are most frequently used in agile developments are use cases and user stories. These are either written or diagrammatic descriptions of how the system will interact with users or other systems and provide an indication of what will be required from the product.
			\\\\
			Because the application being produced is a prototype and there are no defined stakeholders, the only requirements analysis technique which would be applicable is production of use cases. These can aid in identifying how the application will be operated by users and what the project will need to produce. These requirements can then be prioritised using the MoSCoW format and inserted into a tracking system for the development process as described in the following sections.
		\paragraph{MoSCoW}
			First used in the DSDM agile framework \citep{bittner2002use}, MoSCoW analysis or prioritisation is the process of taking the requirements of a software product and placing them into one of four categories; Must, Should, Could, and Won’t have. These deliverables may then be prioritised either for the entire project or for individual sprint cycles depending on the size and magnitude of the project.
			\\\\
			MoSCoW was created to give customers a better understanding of software requirements. Unlike categorizing priorities as high, medium and low, MoSCoW is more descriptive of what the prioritisation means for the software project. From a development point of view, this prioritisation process allows developers to focus on the core requirements of the project first, creating a viable software solution early in the development cycle with less important features being added later if the resources are available.
			\\\\
			This project could use MoSCoW to prioritise the requirements identified using the requirements analysis technique. This will ensure that the core aspects of the solution are implemented first creating a successful project early and allowing it to improve as time allows.
		\paragraph{Sprint Cycles}
			Used by Scrum development teams \citep{rising2000scrum}, a sprint is a timeboxed effort of work scheduled to take between one week and one month. At the start of a sprint, goals are chosen from the project requirements which are to be completed by the end of the sprint. When a sprint is complete a retrospective review is carried out by the development team to discuss what went well, what didn’t, and how this can be rectified in the next sprint.
			\\\\
			This project could use sprints in the same manner as an agile development team as this would allow easier completion of requirements and tighter management of the development process. Using sprints would ensure the time allotted for development is used effectively which may lead to a higher quality product at the end of the project. 
			\\\\
			As mentioned previously, MoSCoW prioritised requirements are selected at the start of each sprint cycle to set objectives for the work which will be carried out. Each cycle aims to complete all of the must have requirements and the majority of should and could haves. At the end of each cycle, a retrospective review is carried out which will re-prioritise any uncompleted requirements based on how successful the sprint cycle was. This means requirements may be promoted or demoted respectively.
		\subsubsection{Organic Development}
			An alternative method to agile development could be to take a more organic approach to the development process. This method would take the step-by-step ethic of agile and reduce the effort applied for analysis, documentation, and structuring of the working schedule.
			\\\\
			To initiate the development process without analysis of requirements would be to begin producing the basic steps or functionality which the system will go through from a vision of the end product. Once started, development would take a natural direction identified by what is needed for the system or to solve any issues encountered.
			\\\\
			To document the development process, a daily log of any work completed would be kept whenever any development is carried out. This would allow for referral at later dates and keep the project on track by identifying when features are completed.
			\\\\
			There are advantages and disadvantages to using this method over an agile process. Due to the size of the software being produced the amount of management work inherent in an agile process could mean the development process is over managed
		\subsubsection{Version Control}\label{sec:methodology_version_control}
			Large software projects produce multiple files of code, data and documentation. These are are vital to the overall success of a project and should be kept safe. Were these files to be lost then the project could easily be delayed or drawn to a close as the time and resources may not be available to recreate the lost data. To combat this any data relating to the project must be backed up, preferably on a cloud based system, to avoid loss and allow the project to continue should anything happen to the local copy of the data.
			\\\\
			For this project the Git \gls{vcs} will be used. Git uses a cloud hosted repository to store any files relating to a project and allows for work to be carried out locally by cloning the repository on a computer. However \glspl{vcs} also enables the management of the previous versions of files including information such as the individual changes made, details of when those changes were made, and who made them This is a powerful tool as it means the various sections of the project can be worked on without the risk of damaging the project and should a change prove unsuccessful then the repository can be reverted to a functional point.
			\\\\
			For this project the web service used to host the repository will be github.com. This site was chosen as it provides unlimited free repositories as well as simple repository management tools. The website also provides issue tracking functionality which will be used to log each new feature as it is added, although strictly speaking they are not issues at all. The reason for this is that all features logged in the repository will have a unique identification and description against which commits are recorded. This is useful for project management reasons as then each feature’s stage and completeness can be monitored to ensure the project’s success.
			\\\\
			Alternative \glspl{vcs}, such as Microsoft’s Team Foundation Server or Perforce, are available. However these are limited under free licences or locked to certain development environments whereas the accessibility and ease of use provided by Git makes it the optimal \gls{vcs} to use for this project.
	\subsubsection{Milestones}
		Milestones are used in project management to mark significant events or points within a project’s timeline. This allows a further breakdown of the project into milestones which can then be used as intermediary deadlines. The use of milestones allows the project manager, management team, or development team to keep track of the project’s status and priorities at any given time.
		\\\\
		This project has, and will use, milestones for exactly the same reason. Current examples include the week nine review session and the deadline for the completion of this document. As more milestones are identified through breaking down the development process into development sprints and other ancillary tasks, they too will be documented and acted upon.
	\subsubsection{Threshold}
		Tasks taking up more than their allotted time is a common cause of projects consuming more resource than initially allocated. To ensure all tasks can be completed within the allotted time for this project, each task will be allocated a threshold. Adding a threshold is a common technique in project management and provides extra time should anything unexpected occur which impacts the timely delivery of the project.
	\subsubsection{Gantt Chart}\label{sec:methodology_gantt}
		A Gantt chart is a method of breaking down a project into tasks and graphically representing them as bars on a chart first used by Henry Gantt in the second decade of the 20th century as a way of ensuring schedules are met. Commonly starting at a project’s inception date and ending with it’s completion date, tasks are allocated an estimated duration for their completion and placed within the timeline. These tasks can then be allocated dependencies to indicate their prerequisites and graphically show the project’s critical path.
		\\\\
		This project will make full use of the Gantt chart technique by decomposing the project into multiple stages for both writing and development. Previously mentioned milestones will also be added for the known fixed points. Each sprint cycle for the development process will be indicated with further notes on the tasks to be carried out. Microsoft Project 2016 will be used to create the Gantt chart.
	\subsection{Evaluation}\label{sec:methodology_evaluation}
		To ensure that the application produced is extensively evaluated, multiple methods will be used. Each of the different methods will evaluate a single aspect of the application from varying points of view.
		\subsubsection{Validation}
			This is a measure of how well a design or solution meets its original specifications and fulfils its intended purpose. It involves checking that all required functionality is present, each output is correct and as expected, and the solution performs as expected.
			\\\\
			In this project, validation will be provided through the implemented unit tests. Ensuring the application has near 100\% coverage and that it has successfully passed each test will confirm that the application is operating as expected.
		\subsubsection{Reliability and Accuracy}
			Assessing the reliability and accuracy of the application proves that the results that it produces are both consistent and correct. To assess these an uncertainty metric will be produced as described below. When taking multiple measurements there is typically a ”true” value which is the actual measurement that falls somewhere within the range of produced measurements. Uncertainty is a prediction of how close any produced measurement will be to this ”true” value, expressed as $\overline{x} \pm U$. The method for producing a value for uncertainty is as follows:
			\begin{enumerate}
				\item Produce a suitable number of repeat measurements $\{x_0 ... x_n\}$
				\item Calculate the average value of these measurements $\overline{x}=\frac{\sum\{x_0...x_n\}}{n}$
				\item Find the differences between the measurements and the average $\{d_0...d_n\} = \{(x_0-\overline{x})...(x_n-\overline{x})\}$
				\item Calculate the average of these differences squared $\overline{d_s} = \frac{\sum\{{d_0}^2...{d_n}^2\}}{n}$
				\item Produce the uncertainty or standard deviation of these results which is the square root of the average differences $U= \sqrt{\overline{d_s}}$
			\end{enumerate}
			This process will be carried out a number of times altering all possible variables depending on what the application is capable of once produced. These variances will be outlined once the evaluation has been completed.
		\subsubsection{Comparison to Alternatives}\label{sec:methodology_manual}
			Comparing the process of using the application to produce a sag setting against other available methods will show how simple the application is to use and whether it is more effective than other methods. For this comparison, outputs from the application will be compared with a trial and error process that is a common practice for a beginner or intermediate rider setting their suspension for the first time as described in section \ref{sec:sag}. If the manufacturer's recommended setting prove to be incorrect, then pressure is increased or removed by set increments. Comparison to this process will indicate whether the application presents a benefit over the manual approach.
		\subsubsection{Professional Opinion}\label{sec:methodology_professional_opinion}
			The final method of evaluation will be to seek the opinion of the application from professionals working within the mountain bike and cycling industry. This will provide further indication of how well the application achieves its goal and how it might be received were it to commercialized as well as suggesting areas for future work which may not have been seen without outside consultation.
			\\\\
			The Mountain Bike Research Centre of Scotland\footnote{http://www.napier.ac.uk/about-us/our-schools/school-of-applied-sciences/research/mountain-bike-centre-of-scotland} will be approached to recommend an individual who they deem suitable to provide such expert assessment once the application can be demonstrated. Although it is anticipated that the meeting will take a semi-formal approach, general evaluative questions will be posed with responses recorded on an appropriate scoring scale where appropriate. 
			\\\\
			In addition to this meeting, the application will also be demonstrated to staff at a local bike shop to also gain their feedback using the same approach as the meeting with the individual designated by The Mountain Bike Research Centre.